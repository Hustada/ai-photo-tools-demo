// © 2025 Mark Hustad — MIT License
// AI-powered blog post generation using OpenAI

import 'dotenv/config';
import { OpenAI } from 'openai';
import type { BlogSession } from './blogSession.js';
import type { GitChangeAnalysis } from './gitAnalysis.js';
// Note: BlogPost type will be imported when needed for publishing

export interface BlogGenerationOptions {
  style?: 'technical' | 'tutorial' | 'overview' | 'deep-dive';
  tone?: 'professional' | 'conversational' | 'educational';
  includeCodeExamples?: boolean;
  includeDiagrams?: boolean;
  targetLength?: 'short' | 'medium' | 'long';
}

export interface GeneratedBlog {
  metadata: {
    title: string;
    description: string;
    author: string;
    readingTime: number;
    tags: string[];
  };
  content: string;
  rawContent: string;
  summary: string;
}

// Initialize OpenAI client
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

// Verify API key is available
if (!process.env.OPENAI_API_KEY) {
  console.warn('[BlogGenerator] OPENAI_API_KEY not found in environment variables');
}

// Main blog generation function
export const generateBlogPost = async (
  session: BlogSession,
  analysis: GitChangeAnalysis,
  options: BlogGenerationOptions = {}
): Promise<GeneratedBlog> => {
  console.log(`[BlogGenerator] Generating blog post for: ${session.featureName}`);
  
  const defaultOptions: Required<BlogGenerationOptions> = {
    style: 'technical',
    tone: 'professional',
    includeCodeExamples: true,
    includeDiagrams: false,
    targetLength: 'medium',
    ...options
  };
  
  try {
    // Generate blog content using OpenAI
    const content = await generateBlogContent(session, analysis, defaultOptions);
    
    // Extract metadata from generated content
    const metadata = extractMetadata(content, session, analysis);
    
    // Calculate reading time
    const readingTime = calculateReadingTime(content);
    
    return {
      metadata: {
        ...metadata,
        readingTime
      },
      content,
      rawContent: content,
      summary: generateSummary(session, analysis)
    };
  } catch (error) {
    console.error('[BlogGenerator] Error generating blog post:', error);
    throw new Error(`Failed to generate blog post: ${(error as Error).message}`);
  }
};

// Generate blog content using OpenAI
const generateBlogContent = async (
  session: BlogSession,
  analysis: GitChangeAnalysis,
  options: Required<BlogGenerationOptions>
): Promise<string> => {
  const prompt = buildPrompt(session, analysis, options);
  
  console.log(`[BlogGenerator] Sending request to OpenAI (${prompt.length} chars)`);
  
  try {
    const response = await openai.chat.completions.create({
      model: 'gpt-4',
      messages: [
        {
          role: 'system',
          content: getSystemPrompt(options)
        },
        {
          role: 'user',
          content: prompt
        }
      ],
      max_tokens: getMaxTokens(options.targetLength),
      temperature: 0.7,
    });
    
    const content = response.choices[0]?.message?.content;
    if (!content) {
      throw new Error('No content generated by OpenAI');
    }
    
    console.log(`[BlogGenerator] ✅ Generated ${content.length} characters of content`);
    return content;
  } catch (error) {
    console.error('[BlogGenerator] OpenAI API error:', error);
    throw new Error(`OpenAI generation failed: ${(error as Error).message}`);
  }
};

// Build the prompt for OpenAI
const buildPrompt = (
  session: BlogSession,
  analysis: GitChangeAnalysis,
  options: Required<BlogGenerationOptions>
): string => {
  const { featureName, description, tags } = session;
  const { summary, commits, codeSnippets } = analysis;
  
  let prompt = `# Blog Post Generation Request

## Feature Information
- **Feature Name**: ${featureName}
- **Description**: ${description || 'No description provided'}
- **Branch**: ${session.startBranch}
- **Tags**: ${tags?.join(', ') || 'General Development'}

## Change Analysis Summary
- **Commits**: ${analysis.commitCount}
- **Files Changed**: ${summary.totalFiles} (${summary.newFiles} new, ${summary.modifiedFiles} modified)
- **Lines of Code**: +${summary.totalInsertions}/-${summary.totalDeletions}
- **Primary Languages**: ${summary.primaryLanguages.join(', ')}
- **Categories**: ${summary.categories.join(', ')}
- **Test Files**: ${summary.testFiles}`;

  if (summary.architecturalChanges.length > 0) {
    prompt += `\n- **Architectural Changes**: ${summary.architecturalChanges.join(', ')}`;
  }

  // Add commit history
  if (commits.length > 0) {
    prompt += `\n\n## Commit History\n`;
    commits.forEach(commit => {
      prompt += `- **${commit.shortHash}**: ${commit.message} (+${commit.insertions}/-${commit.deletions})\n`;
    });
  }

  // Add code snippets if requested
  if (options.includeCodeExamples && codeSnippets.length > 0) {
    prompt += `\n\n## Key Code Changes (USE THESE EXACT SNIPPETS IN YOUR ARTICLE)\n`;
    prompt += `IMPORTANT: These are the actual code changes from the implementation. You MUST use these exact code snippets when showing code examples in your article. Do not create placeholder code or generic examples.\n\n`;
    codeSnippets.forEach((snippet, i) => {
      prompt += `\n### Code Snippet ${i + 1}: ${snippet.description}\n`;
      prompt += `**File**: ${snippet.file}\n`;
      prompt += `**Language**: ${snippet.language}\n`;
      if (snippet.before) {
        prompt += `**Before (original code)**:\n`;
        prompt += `\`\`\`${snippet.language}\n${snippet.before}\n\`\`\`\n`;
        prompt += `**After (your implementation)**:\n`;
      }
      prompt += `\`\`\`${snippet.language}\n${snippet.after}\n\`\`\`\n`;
      prompt += `Use this code when explaining the ${snippet.description.toLowerCase()}.\n`;
    });
  }

  // Add specific instructions based on analysis
  prompt += `\n\n## Additional Context\n`;
  
  if (summary.hasNewComponents) {
    prompt += `- This feature introduces new React components\n`;
  }
  
  if (summary.hasNewTests) {
    prompt += `- Test-driven development approach with new test coverage\n`;
  }
  
  if (summary.hasAPIChanges) {
    prompt += `- Includes API endpoint changes or additions\n`;
  }
  
  if (summary.hasUIChanges) {
    prompt += `- User interface and styling updates\n`;
  }

  prompt += `\n\nGenerate a comprehensive technical blog post that tells the complete story of this implementation.

FINAL REMINDERS:
- Use the EXACT code snippets provided above - do not create generic examples
- Write as the expert who built this feature
- Focus on the real implementation details and challenges
- Explain the reasoning behind every technical decision
- Make it engaging and educational for fellow developers`;
  
  return prompt;
};

// Get system prompt based on options
const getSystemPrompt = (options: Required<BlogGenerationOptions>): string => {
  const basePrompt = `You are an expert software engineer writing an in-depth technical article for a professional coding blog (like Medium, Dev.to, or Hashnode). You have deep expertise in the technologies used in this implementation.

Based on the git analysis and code changes provided, you are THE expert who implemented this feature. Study the commits, code changes, and technical details to understand:
- What technologies were used
- What problems were solved
- What architectural patterns were employed
- What performance considerations were addressed

Write with the authority of someone who:
- Has mastery of every technology mentioned in the codebase
- Understands the nuances and trade-offs of the approaches taken
- Can explain complex concepts clearly to other developers
- Has battle-tested these solutions in production

CRITICAL INSTRUCTIONS:
- Infer your expertise from the code analysis provided
- Write as if YOU personally implemented every line of code
- Demonstrate deep knowledge of the specific technologies used
- Use the EXACT code snippets provided - these are YOUR implementations
- Explain the WHY behind every technical decision
- Discuss real-world implications and edge cases
- Share insights that only come from hands-on experience

ARTICLE STYLE:
- Professional but engaging - like the best technical blog posts
- Technical depth that respects the reader's intelligence
- Code-heavy with thorough explanations
- Honest about challenges while demonstrating expertise
- Focus on practical insights and lessons learned

DERIVE YOUR NARRATIVE FROM THE DATA:
- Study the commit messages to understand the development journey
- Analyze the code changes to identify key technical decisions
- Use the file paths and changes to infer the architecture
- Let the actual implementation guide your expertise claims

Write naturally, starting with the problem, walking through the solution, showing implementation details, discussing challenges, and concluding with key takeaways. Let the code tell the story.

DO NOT include any structural markers like "Title:", "Byline:", or numbered sections. Write pure article content that flows naturally.`;

  // Customize based on options
  if (options.tone === 'conversational') {
    basePrompt += `\n\n**Tone Adjustment**: Use a more conversational, friendly tone while maintaining technical accuracy.`;
  } else if (options.tone === 'educational') {
    basePrompt += `\n\n**Tone Adjustment**: Focus on teaching concepts and providing learning opportunities.`;
  }

  if (options.style === 'tutorial') {
    basePrompt += `\n\n**Style Adjustment**: Structure as a step-by-step tutorial with actionable instructions.`;
  } else if (options.style === 'deep-dive') {
    basePrompt += `\n\n**Style Adjustment**: Provide extensive technical depth and comprehensive analysis.`;
  }

  return basePrompt;
};

// Get max tokens based on target length
const getMaxTokens = (targetLength: 'short' | 'medium' | 'long'): number => {
  switch (targetLength) {
    case 'short': return 1500;
    case 'long': return 4000;
    case 'medium':
    default: return 2500;
  }
};

// Extract metadata from generated content
const extractMetadata = (content: string, session: BlogSession, analysis: GitChangeAnalysis) => {
  // Extract title (first # heading)
  const titleMatch = content.match(/^#\s+(.+)$/m);
  const title = titleMatch ? titleMatch[1] : session.featureName;
  
  // Extract description (first paragraph after title)
  const lines = content.split('\n');
  let description = '';
  let foundTitle = false;
  
  for (const line of lines) {
    if (line.startsWith('# ') && !foundTitle) {
      foundTitle = true;
      continue;
    }
    
    if (foundTitle && line.trim() && !line.startsWith('*') && !line.startsWith('#')) {
      description = line.trim();
      break;
    }
  }
  
  // Fallback description
  if (!description) {
    description = `Technical implementation of ${session.featureName} with comprehensive analysis and insights.`;
  }
  
  // Limit description length
  if (description.length > 160) {
    description = description.substring(0, 157) + '...';
  }
  
  // Determine author based on git commits
  const authors = [...new Set(analysis.commits.map(c => c.author))];
  const author = authors.length === 1 ? authors[0] : 'CodeCraft';
  
  // Generate tags from analysis and session
  const generatedTags = generateTags(session, analysis);
  
  return {
    title,
    description,
    author,
    tags: generatedTags
  };
};

// Generate relevant tags from analysis
const generateTags = (session: BlogSession, analysis: GitChangeAnalysis): string[] => {
  const tags = new Set<string>();
  
  // Add session tags if available
  if (session.tags) {
    session.tags.forEach(tag => tags.add(tag));
  }
  
  // Add tags based on analysis
  if (analysis.summary.hasNewComponents) {
    tags.add('React Components');
  }
  
  if (analysis.summary.hasNewTests) {
    tags.add('Testing');
  }
  
  if (analysis.summary.hasAPIChanges) {
    tags.add('API Development');
  }
  
  if (analysis.summary.hasUIChanges) {
    tags.add('UI/UX');
  }
  
  // Add language tags
  analysis.summary.primaryLanguages.forEach(lang => {
    if (lang === 'typescript') tags.add('TypeScript');
    if (lang === 'javascript') tags.add('JavaScript');
    if (lang === 'css') tags.add('CSS');
  });
  
  // Add category-based tags
  if (analysis.summary.categories.includes('util')) {
    tags.add('Utilities');
  }
  
  if (analysis.summary.architecturalChanges.includes('Performance optimization')) {
    tags.add('Performance');
  }
  
  if (analysis.summary.architecturalChanges.includes('Test-driven development')) {
    tags.add('TDD');
  }
  
  // Default tags
  tags.add('Development');
  tags.add('Technical Documentation');
  
  return Array.from(tags).slice(0, 6); // Limit to 6 tags
};

// Calculate reading time (average 200 words per minute)
const calculateReadingTime = (content: string): number => {
  const wordsPerMinute = 200;
  const wordCount = content.trim().split(/\s+/).length;
  return Math.max(1, Math.ceil(wordCount / wordsPerMinute));
};

// Generate summary for the blog post
const generateSummary = (session: BlogSession, analysis: GitChangeAnalysis): string => {
  const { featureName } = session;
  const { summary } = analysis;
  
  let summaryText = `Implementation of ${featureName} featuring `;
  
  const features = [];
  
  if (summary.hasNewComponents) {
    features.push('new React components');
  }
  
  if (summary.hasAPIChanges) {
    features.push('API enhancements');
  }
  
  if (summary.hasNewTests) {
    features.push('comprehensive testing');
  }
  
  if (summary.totalInsertions > 500) {
    features.push('extensive code additions');
  }
  
  if (summary.architecturalChanges.length > 0) {
    features.push(summary.architecturalChanges[0].toLowerCase());
  }
  
  summaryText += features.slice(0, 3).join(', ');
  
  if (features.length > 3) {
    summaryText += `, and ${features.length - 3} other improvements`;
  }
  
  summaryText += `. Includes ${summary.totalInsertions} lines of new code across ${summary.totalFiles} files.`;
  
  return summaryText;
};