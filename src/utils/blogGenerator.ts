// © 2025 Mark Hustad — MIT License
// AI-powered blog post generation using OpenAI

import { OpenAI } from 'openai';
import type { BlogSession } from './blogSession.js';
import type { GitChangeAnalysis } from './gitAnalysis.js';
// Note: BlogPost type will be imported when needed for publishing

export interface BlogGenerationOptions {
  style?: 'technical' | 'tutorial' | 'overview' | 'deep-dive';
  tone?: 'professional' | 'conversational' | 'educational';
  includeCodeExamples?: boolean;
  includeDiagrams?: boolean;
  targetLength?: 'short' | 'medium' | 'long';
}

export interface GeneratedBlog {
  metadata: {
    title: string;
    description: string;
    author: string;
    readingTime: number;
    tags: string[];
  };
  content: string;
  rawContent: string;
  summary: string;
}

// Initialize OpenAI client
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

// Main blog generation function
export const generateBlogPost = async (
  session: BlogSession,
  analysis: GitChangeAnalysis,
  options: BlogGenerationOptions = {}
): Promise<GeneratedBlog> => {
  console.log(`[BlogGenerator] Generating blog post for: ${session.featureName}`);
  
  const defaultOptions: Required<BlogGenerationOptions> = {
    style: 'technical',
    tone: 'professional',
    includeCodeExamples: true,
    includeDiagrams: false,
    targetLength: 'medium',
    ...options
  };
  
  try {
    // Generate blog content using OpenAI
    const content = await generateBlogContent(session, analysis, defaultOptions);
    
    // Extract metadata from generated content
    const metadata = extractMetadata(content, session, analysis);
    
    // Calculate reading time
    const readingTime = calculateReadingTime(content);
    
    return {
      metadata: {
        ...metadata,
        readingTime
      },
      content,
      rawContent: content,
      summary: generateSummary(session, analysis)
    };
  } catch (error) {
    console.error('[BlogGenerator] Error generating blog post:', error);
    throw new Error(`Failed to generate blog post: ${(error as Error).message}`);
  }
};

// Generate blog content using OpenAI
const generateBlogContent = async (
  session: BlogSession,
  analysis: GitChangeAnalysis,
  options: Required<BlogGenerationOptions>
): Promise<string> => {
  const prompt = buildPrompt(session, analysis, options);
  
  console.log(`[BlogGenerator] Sending request to OpenAI (${prompt.length} chars)`);
  
  try {
    const response = await openai.chat.completions.create({
      model: 'gpt-4',
      messages: [
        {
          role: 'system',
          content: getSystemPrompt(options)
        },
        {
          role: 'user',
          content: prompt
        }
      ],
      max_tokens: getMaxTokens(options.targetLength),
      temperature: 0.7,
    });
    
    const content = response.choices[0]?.message?.content;
    if (!content) {
      throw new Error('No content generated by OpenAI');
    }
    
    console.log(`[BlogGenerator] ✅ Generated ${content.length} characters of content`);
    return content;
  } catch (error) {
    console.error('[BlogGenerator] OpenAI API error:', error);
    throw new Error(`OpenAI generation failed: ${(error as Error).message}`);
  }
};

// Build the prompt for OpenAI
const buildPrompt = (
  session: BlogSession,
  analysis: GitChangeAnalysis,
  options: Required<BlogGenerationOptions>
): string => {
  const { featureName, description, tags } = session;
  const { summary, commits, codeSnippets } = analysis;
  
  let prompt = `# Blog Post Generation Request

## Feature Information
- **Feature Name**: ${featureName}
- **Description**: ${description || 'No description provided'}
- **Branch**: ${session.startBranch}
- **Tags**: ${tags?.join(', ') || 'General Development'}

## Change Analysis Summary
- **Commits**: ${analysis.commitCount}
- **Files Changed**: ${summary.totalFiles} (${summary.newFiles} new, ${summary.modifiedFiles} modified)
- **Lines of Code**: +${summary.totalInsertions}/-${summary.totalDeletions}
- **Primary Languages**: ${summary.primaryLanguages.join(', ')}
- **Categories**: ${summary.categories.join(', ')}
- **Test Files**: ${summary.testFiles}`;

  if (summary.architecturalChanges.length > 0) {
    prompt += `\n- **Architectural Changes**: ${summary.architecturalChanges.join(', ')}`;
  }

  // Add commit history
  if (commits.length > 0) {
    prompt += `\n\n## Commit History\n`;
    commits.forEach(commit => {
      prompt += `- **${commit.shortHash}**: ${commit.message} (+${commit.insertions}/-${commit.deletions})\n`;
    });
  }

  // Add code snippets if requested
  if (options.includeCodeExamples && codeSnippets.length > 0) {
    prompt += `\n\n## Key Code Changes\n`;
    codeSnippets.forEach((snippet, i) => {
      prompt += `\n### ${i + 1}. ${snippet.description}\n`;
      prompt += `**File**: ${snippet.file}\n`;
      prompt += `**Language**: ${snippet.language}\n`;
      prompt += `\`\`\`${snippet.language}\n${snippet.after}\n\`\`\`\n`;
    });
  }

  // Add specific instructions based on analysis
  prompt += `\n\n## Additional Context\n`;
  
  if (summary.hasNewComponents) {
    prompt += `- This feature introduces new React components\n`;
  }
  
  if (summary.hasNewTests) {
    prompt += `- Test-driven development approach with new test coverage\n`;
  }
  
  if (summary.hasAPIChanges) {
    prompt += `- Includes API endpoint changes or additions\n`;
  }
  
  if (summary.hasUIChanges) {
    prompt += `- User interface and styling updates\n`;
  }

  prompt += `\n\nPlease generate a comprehensive technical blog post following the CodeCraft style guide.`;
  
  return prompt;
};

// Get system prompt based on options
const getSystemPrompt = (options: Required<BlogGenerationOptions>): string => {
  const basePrompt = `You are CodeCraft, the technical documentation companion for the Scout AI project. You write comprehensive, engaging technical blog posts that combine deep technical insights with clear explanations.

## Your Writing Style:
- **Voice**: Professional yet approachable, enthusiastic about technology
- **Structure**: Clear hierarchy with meaningful sections
- **Focus**: Both the "how" and "why" behind technical decisions
- **Audience**: Fellow developers, from intermediate to senior level

## Blog Post Structure (REQUIRED):
1. **Title**: Descriptive and engaging (60-80 characters)
2. **Byline**: *Date - Author* format
3. **Introduction**: Context and motivation (2-3 paragraphs)
4. **The Challenge**: What problem were we solving?
5. **Technical Implementation**: Detailed walkthrough with code examples
6. **Key Features**: Bullet points of main capabilities
7. **Performance Benefits** or **Architecture Decisions**: Metrics and reasoning
8. **Lessons Learned**: Insights and best practices
9. **Conclusion**: Summary and next steps
10. **Footer**: Brief sign-off with project context

## Content Requirements:
- Use proper markdown formatting with syntax highlighting
- Include actual code snippets from the analysis when relevant
- Explain architectural decisions and trade-offs
- Highlight testing approach and quality measures
- Mention performance implications where applicable
- Keep technical depth appropriate for the changes made

## Brand Voice:
- Scout AI is an AI-powered photo management platform for construction professionals
- CodeCraft creates documentation that captures the journey of building this platform
- Focus on practical takeaways and real-world application
- Maintain consistency with existing blog posts in the system`;

  // Customize based on options
  if (options.tone === 'conversational') {
    basePrompt += `\n\n**Tone Adjustment**: Use a more conversational, friendly tone while maintaining technical accuracy.`;
  } else if (options.tone === 'educational') {
    basePrompt += `\n\n**Tone Adjustment**: Focus on teaching concepts and providing learning opportunities.`;
  }

  if (options.style === 'tutorial') {
    basePrompt += `\n\n**Style Adjustment**: Structure as a step-by-step tutorial with actionable instructions.`;
  } else if (options.style === 'deep-dive') {
    basePrompt += `\n\n**Style Adjustment**: Provide extensive technical depth and comprehensive analysis.`;
  }

  return basePrompt;
};

// Get max tokens based on target length
const getMaxTokens = (targetLength: 'short' | 'medium' | 'long'): number => {
  switch (targetLength) {
    case 'short': return 1500;
    case 'long': return 4000;
    case 'medium':
    default: return 2500;
  }
};

// Extract metadata from generated content
const extractMetadata = (content: string, session: BlogSession, analysis: GitChangeAnalysis) => {
  // Extract title (first # heading)
  const titleMatch = content.match(/^#\s+(.+)$/m);
  const title = titleMatch ? titleMatch[1] : session.featureName;
  
  // Extract description (first paragraph after title)
  const lines = content.split('\n');
  let description = '';
  let foundTitle = false;
  
  for (const line of lines) {
    if (line.startsWith('# ') && !foundTitle) {
      foundTitle = true;
      continue;
    }
    
    if (foundTitle && line.trim() && !line.startsWith('*') && !line.startsWith('#')) {
      description = line.trim();
      break;
    }
  }
  
  // Fallback description
  if (!description) {
    description = `Technical implementation of ${session.featureName} with comprehensive analysis and insights.`;
  }
  
  // Limit description length
  if (description.length > 160) {
    description = description.substring(0, 157) + '...';
  }
  
  // Determine author based on git commits
  const authors = [...new Set(analysis.commits.map(c => c.author))];
  const author = authors.length === 1 ? authors[0] : 'CodeCraft';
  
  // Generate tags from analysis and session
  const generatedTags = generateTags(session, analysis);
  
  return {
    title,
    description,
    author,
    tags: generatedTags
  };
};

// Generate relevant tags from analysis
const generateTags = (session: BlogSession, analysis: GitChangeAnalysis): string[] => {
  const tags = new Set<string>();
  
  // Add session tags if available
  if (session.tags) {
    session.tags.forEach(tag => tags.add(tag));
  }
  
  // Add tags based on analysis
  if (analysis.summary.hasNewComponents) {
    tags.add('React Components');
  }
  
  if (analysis.summary.hasNewTests) {
    tags.add('Testing');
  }
  
  if (analysis.summary.hasAPIChanges) {
    tags.add('API Development');
  }
  
  if (analysis.summary.hasUIChanges) {
    tags.add('UI/UX');
  }
  
  // Add language tags
  analysis.summary.primaryLanguages.forEach(lang => {
    if (lang === 'typescript') tags.add('TypeScript');
    if (lang === 'javascript') tags.add('JavaScript');
    if (lang === 'css') tags.add('CSS');
  });
  
  // Add category-based tags
  if (analysis.summary.categories.includes('util')) {
    tags.add('Utilities');
  }
  
  if (analysis.summary.architecturalChanges.includes('Performance optimization')) {
    tags.add('Performance');
  }
  
  if (analysis.summary.architecturalChanges.includes('Test-driven development')) {
    tags.add('TDD');
  }
  
  // Default tags
  tags.add('Development');
  tags.add('Technical Documentation');
  
  return Array.from(tags).slice(0, 6); // Limit to 6 tags
};

// Calculate reading time (average 200 words per minute)
const calculateReadingTime = (content: string): number => {
  const wordsPerMinute = 200;
  const wordCount = content.trim().split(/\s+/).length;
  return Math.max(1, Math.ceil(wordCount / wordsPerMinute));
};

// Generate summary for the blog post
const generateSummary = (session: BlogSession, analysis: GitChangeAnalysis): string => {
  const { featureName } = session;
  const { summary } = analysis;
  
  let summaryText = `Implementation of ${featureName} featuring `;
  
  const features = [];
  
  if (summary.hasNewComponents) {
    features.push('new React components');
  }
  
  if (summary.hasAPIChanges) {
    features.push('API enhancements');
  }
  
  if (summary.hasNewTests) {
    features.push('comprehensive testing');
  }
  
  if (summary.totalInsertions > 500) {
    features.push('extensive code additions');
  }
  
  if (summary.architecturalChanges.length > 0) {
    features.push(summary.architecturalChanges[0].toLowerCase());
  }
  
  summaryText += features.slice(0, 3).join(', ');
  
  if (features.length > 3) {
    summaryText += `, and ${features.length - 3} other improvements`;
  }
  
  summaryText += `. Includes ${summary.totalInsertions} lines of new code across ${summary.totalFiles} files.`;
  
  return summaryText;
};